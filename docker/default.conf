server {
    listen 80;
    server_name localhost;

    # Health check endpoint should respond on HTTP without redirecting to HTTPS
    location = /health {
        add_header Content-Type text/plain;
        return 200 'OK';
    }

    # Redirect all HTTP requests to HTTPS (no basic auth needed since Authelia handles auth)
    location / {
        # Redirect to HTTPS preserving the request
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name localhost;

    ssl_certificate     /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    index index.php index.html;
    # Default root points to web app
    root /var/www/web/public;
    client_max_body_size 64M;
    
    # Timeout settings
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;
    fastcgi_read_timeout 600;
    fastcgi_send_timeout 600;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Handle React Router (SPA)
    # Allow health check on HTTPS without authentication
    location = /health {
        add_header Content-Type text/plain;
        return 200 'OK';
    }

    # Web (frontend) app
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # CMS (backend) mounted under /deltaecho â€” isolate all /deltaecho requests to CMS
    # Canonicalize /deltaecho to /deltaecho/
    location = /deltaecho {
        return 301 /deltaecho/;
    }

    # JWT-protected API endpoints - no Authelia authentication required
    # Laravel automatically prefixes api.php routes with /api, so these routes are at /deltaecho/api/internal/*
    location ^~ /deltaecho/api/internal/ {
        alias /var/www/cms/public/;
        
        # Handle PHP files for API endpoints
        location ~ \.php$ {
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $request_filename;
            fastcgi_param DOCUMENT_ROOT /var/www/cms/public;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
        }
        
        # API routes go through Laravel's front controller
        try_files $uri $uri/ @cms_api;
    }

    # Internal handler for API routes (no Authelia auth)
    location @cms_api {
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME /var/www/cms/public/index.php;
        fastcgi_param SCRIPT_NAME /index.php;
        fastcgi_param DOCUMENT_ROOT /var/www/cms/public;
        
        # Strip /deltaecho prefix for Laravel routing
        rewrite ^/deltaecho(/.*)$ $1 break;
        fastcgi_param REQUEST_URI $1$is_args$args;
        
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
    }

    # Serve CMS requests under /deltaecho. Use ^~ to prevent regex locations
    # from matching before this block. Files are served via alias from the
    # CMS public directory, and non-file requests fall back to the front controller.
    location ^~ /deltaecho/ {
        alias /var/www/cms/public/;
        
        # Set cache headers for static assets (nested location)
        location ~ \.(css|js|png|jpe?g|svg|gif|ico|woff2?|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header X-Content-Type-Options nosniff;
        }
        
        # Handle PHP files explicitly within this location
        location ~ \.php$ {
            include fastcgi_params;
            # When using alias, we must construct SCRIPT_FILENAME from the aliased path
            # $request_filename already contains the full aliased filesystem path
            fastcgi_param SCRIPT_FILENAME $request_filename;
            fastcgi_param DOCUMENT_ROOT /var/www/cms/public;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
        }
        
        # For non-PHP files: try file, then directory (with index.php), then front controller
        try_files $uri $uri/ @cms;
    }

    # Internal handler used when try_files falls back (non-PHP URIs). This
    # invokes the CMS front controller at /var/www/cms/public/index.php while
    # stripping the /deltaecho prefix so Laravel sees routes like /login instead of /deltaecho/login.
    location @cms {
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME /var/www/cms/public/index.php;
        fastcgi_param SCRIPT_NAME /index.php;
        fastcgi_param DOCUMENT_ROOT /var/www/cms/public;
        
        # Manually construct REQUEST_URI by stripping /deltaecho prefix from the original request
        # Use a rewrite to capture the path, then pass it to fastcgi
        rewrite ^/deltaecho(/.*)$ $1 break;
        fastcgi_param REQUEST_URI $1$is_args$args;
        
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
    }

    # Handle PHP files for web (default root)
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param DOCUMENT_ROOT $document_root;
    }

    # Cache static assets
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        try_files $uri =404;
    }

    # Deny access to hidden files
    location ~ /\.ht {
        deny all;
    }

    # Deny access to sensitive files
    location ~ /\.(env|git) {
        deny all;
    }

    # Handle Laravel storage symlinks
    location /storage {
        try_files $uri $uri/ =404;
    }

    # ---------- HCUC ---------- #
    # Canonicalize /hcuc to /hcuc/
    location = /hcuc {
        return 301 /hcuc/;
    }

    # Serve HCUC app mounted under /hcuc/ using an alias. Use ^~ so regex
    # locations don't take precedence. Files are served from the aliased
    # path and non-file requests fall back to the HCUC front controller.
    location ^~ /hcuc/ {
        alias /var/www/hcuc/;

        # Static asset caching for HCUC
        location ~ \.(css|js|png|jpe?g|svg|gif|ico|woff2?|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header X-Content-Type-Options nosniff;
            try_files $uri =404;
        }

        # Explicitly handle PHP files inside the aliased directory
        location ~ \.php$ {
            include fastcgi_params;
            # When using alias, $request_filename contains the full filesystem
            # path to the resolved aliased file. Use that for SCRIPT_FILENAME to
            # avoid "Primary script unknown" and "File not found" issues.
            fastcgi_param SCRIPT_FILENAME $request_filename;
            fastcgi_param DOCUMENT_ROOT /var/www/hcuc;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
        }

        # For everything else: try file, then directory, then internal @hcuc handler
        # The @hcuc handler will invoke the HCUC front controller while
        # ensuring SCRIPT_FILENAME points to the aliased index.php.
        try_files $uri $uri/ @hcuc;
    }

    # Internal handler used when try_files falls back. This invokes the
    # HCUC front controller while stripping the /hcuc prefix so the app
    # sees clean routes (e.g. /login rather than /hcuc/login).
    location @hcuc {
        include fastcgi_params;
        # Execute the aliased front controller directly so PHP-FPM receives a
        # valid filesystem path. This avoids "Primary script unknown" errors
        # when requests are rewritten internally.
        fastcgi_param SCRIPT_FILENAME /var/www/hcuc/index.php;
        fastcgi_param SCRIPT_NAME /index.php;
        fastcgi_param DOCUMENT_ROOT /var/www/hcuc;

        # HCUC's legacy routing expects QUERY_STRING to contain the path
        # Extract the path after /hcuc and pass it as QUERY_STRING
        # Use set to capture and store the URI for later use
        set $hcuc_path $request_uri;
        if ($hcuc_path ~ ^/hcuc(.*)$) {
            set $hcuc_path $1;
        }
        
        fastcgi_param REQUEST_URI $hcuc_path;
        fastcgi_param QUERY_STRING $hcuc_path;

        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
    }

    # ---------- PRODUCTRECALL ---------- #
    # Canonicalize /productrecall to /productrecall/
    location = /productrecall {
        return 301 /productrecall/;
    }

    # Serve ProductRecall app mounted under /productrecall/ using an alias. Use ^~ so regex
    # locations don't take precedence. Files are served from the aliased
    # path and non-file requests fall back to the ProductRecall front controller.
    location ^~ /productrecall/ {
        alias /var/www/productrecall/;

        # Static asset caching for ProductRecall
        location ~ \.(css|js|png|jpe?g|svg|gif|ico|woff2?|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header X-Content-Type-Options nosniff;
            try_files $uri =404;
        }

        # Explicitly handle PHP files inside the aliased directory
        location ~ \.php$ {
            include fastcgi_params;
            # When using alias, $request_filename contains the full filesystem
            # path to the resolved aliased file. Use that for SCRIPT_FILENAME to
            # avoid "Primary script unknown" and "File not found" issues.
            fastcgi_param SCRIPT_FILENAME $request_filename;
            fastcgi_param DOCUMENT_ROOT /var/www/productrecall;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
        }

        # For everything else: try file, then directory, then internal @productrecall handler
        # The @productrecall handler will invoke the ProductRecall front controller while
        # ensuring SCRIPT_FILENAME points to the aliased index.php.
        try_files $uri $uri/ @productrecall;
    }

    # Internal handler used when try_files falls back. This invokes the
    # ProductRecall front controller while stripping the /productrecall prefix so the app
    # sees clean routes (e.g. /login rather than /productrecall/login).
    location @productrecall {
        include fastcgi_params;
        # Execute the aliased front controller directly so PHP-FPM receives a
        # valid filesystem path. This avoids "Primary script unknown" errors
        # when requests are rewritten internally.
        fastcgi_param SCRIPT_FILENAME /var/www/productrecall/index.php;
        fastcgi_param SCRIPT_NAME /index.php;
        fastcgi_param DOCUMENT_ROOT /var/www/productrecall;

    # Expose the original path as REQUEST_URI and QUERY_STRING minus the /productrecall prefix
    # so legacy code that reads $_SERVER['QUERY_STRING'] (e.g. index.php?/EN/home)
    # still works when using pretty URLs.
    rewrite ^/productrecall(/.*)$ $1 break;
    fastcgi_param REQUEST_URI $1$is_args$args;
    fastcgi_param QUERY_STRING $1$is_args$args;

        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
    }
}